'use client';

import { useState, useEffect, useRef } from 'react';
import { ChatMessage } from './ChatMessage';
import { ChatInput } from './ChatInput';
import { ProgressBar } from './ProgressBar';
import { QuickReplyOptions } from './QuickReplyOptions';
import { VerificationInput } from './VerificationInput';
import { Message, ChatState, LeadData } from '@/lib/types';
import { getDynamicChatFlow } from '@/lib/chat/dynamic-flow';
import { chatFlow as staticFlow, validateInput } from '@/lib/chat/flow';
import { v4 as uuidv4 } from 'uuid';
import { Sparkles } from 'lucide-react';
import { logger } from '@/lib/utils/logger';

export function DynamicChatInterface() {
  const [chatState, setChatState] = useState<ChatState>({
    currentStep: 'welcome',
    messages: [],
    leadData: {},
    isCompleted: false
  });

  const [isTyping, setIsTyping] = useState(false);
  const [phoneNumber, setPhoneNumber] = useState<string>('');
  const [dynamicFlow, setDynamicFlow] = useState<any>(null);
  const [isLoadingFlow, setIsLoadingFlow] = useState(true);
  const [totalSteps, setTotalSteps] = useState(7); // ÎèôÏ†ÅÏúºÎ°ú Í≥ÑÏÇ∞Îê† Ï†ÑÏ≤¥ Îã®Í≥Ñ Ïàò
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [chatState.messages]);

  useEffect(() => {
    loadDynamicFlow();

    // LocalStorage Î≥ÄÍ≤Ω Í∞êÏßÄÎ•º ÏúÑÌïú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    const handleStorageChange = (e: StorageEvent) => {
      // ÏßàÎ¨∏Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏Îêú Í≤ΩÏö∞ Îã§Ïãú Î°úÎìú
      if (e.key === 'questionsUpdated' || e.key === 'chatQuestions') {
        // Ï∫êÏãú Î¨¥Ìö®Ìôî Î∞è Ïû¨Î°úÎìú
        const flowService = getDynamicChatFlow();
        flowService.invalidateCache();
        loadDynamicFlow();
      }
    };

    // Í∞ôÏùÄ Ï∞Ω ÎÇ¥ÏóêÏÑúÏùò LocalStorage Î≥ÄÍ≤Ω Í∞êÏßÄÎ•º ÏúÑÌïú Ïª§Ïä§ÌÖÄ Ïù¥Î≤§Ìä∏
    const handleCustomStorageChange = () => {
      const flowService = getDynamicChatFlow();
      flowService.invalidateCache();
      loadDynamicFlow();
    };

    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('questionsUpdated', handleCustomStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('questionsUpdated', handleCustomStorageChange);
    };
  }, []);

  const loadDynamicFlow = async () => {
    setIsLoadingFlow(true);
    try {
      const flowService = getDynamicChatFlow();
      const flow = await flowService.getFlow();
      const startStep = await flowService.getStartStep();

      setDynamicFlow(flow);

      // ÎèôÏ†ÅÏúºÎ°ú Ï†ÑÏ≤¥ Îã®Í≥Ñ Ïàò Í≥ÑÏÇ∞
      const activeSteps = Object.keys(flow).filter(key => {
        // complete Îã®Í≥ÑÎäî Ï†úÏô∏ÌïòÍ≥† Ïã§Ï†ú ÏßàÎ¨∏ Îã®Í≥ÑÎßå Ïπ¥Ïö¥Ìä∏
        return key !== 'complete' && key !== 'phoneVerification';
      });

      // phoneVerificationÏùÄ phone Îã®Í≥ÑÏôÄ Í∞ôÏù¥ Í≥ÑÏÇ∞ÎêòÎØÄÎ°ú +1 Ï∂îÍ∞Ä
      const calculatedSteps = activeSteps.length + 1; // +1 for verification
      setTotalSteps(calculatedSteps);

      setChatState(prev => ({
        ...prev,
        currentStep: startStep
      }));

      const welcomeStep = flow[startStep] || staticFlow.welcome;
      const welcomeMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: welcomeStep.question,
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        messages: [welcomeMessage]
      }));
    } catch (error) {
      // Using static flow when dynamic flow is not available (expected without Supabase)
      setDynamicFlow(staticFlow);

      // Ï†ïÏ†Å ÌîåÎ°úÏö∞Ïùò Îã®Í≥Ñ Ïàò Í≥ÑÏÇ∞
      const staticSteps = Object.keys(staticFlow).filter(key => {
        return key !== 'complete' && key !== 'phoneVerification';
      });
      setTotalSteps(staticSteps.length + 1);

      const welcomeMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: staticFlow.welcome.question,
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        currentStep: 'welcome',
        messages: [welcomeMessage]
      }));
    } finally {
      setIsLoadingFlow(false);
    }
  };

  const getCurrentFlow = () => {
    return dynamicFlow || staticFlow;
  };

  const handleUserInput = async (value: string) => {
    const flow = getCurrentFlow();
    const currentStep = flow[chatState.currentStep];


    if (!currentStep) {
      const fallbackMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: 'Ï£ÑÏÜ°Ìï©ÎãàÎã§. ÏãúÏä§ÌÖú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.',
        timestamp: new Date()
      };
      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, fallbackMessage]
      }));
      return;
    }

    if (currentStep.validation && !currentStep.validation(value)) {
      const errorMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: 'ÏûÖÎ†•ÌïòÏã† Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
        timestamp: new Date()
      };
      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, errorMessage]
      }));
      return;
    }

    const userMessage: Message = {
      id: uuidv4(),
      type: 'user',
      content: value,
      timestamp: new Date()
    };

    setChatState(prev => ({
      ...prev,
      messages: [...prev.messages, userMessage]
    }));

    const updatedLeadData: LeadData = { ...chatState.leadData };

    const stepMapping: Record<string, keyof LeadData> = {
      'welcome': 'service',
      'customService': 'service',
      'budget': 'budget',
      'timeline': 'timeline',
      'details': 'message',
      'name': 'name',
      'phone': 'phone'
    };

    const dataKey = stepMapping[chatState.currentStep];
    if (dataKey) {
      (updatedLeadData as any)[dataKey] = value;
    }

    if (chatState.currentStep === 'phone') {
      setPhoneNumber(value);
    }

    setIsTyping(true);
    setTimeout(async () => {
      setIsTyping(false);

      // ÎîîÎ≤ÑÍπÖ: currentStep Ï†ïÎ≥¥ ÌôïÏù∏
      if (!currentStep.nextStep) {
        logger.error('‚ùå nextStep function is missing for step:', chatState.currentStep);
        logger.error('Current step data:', currentStep);
      }

      const nextStepId = currentStep.nextStep ? currentStep.nextStep(value) : null;
      logger.debug('Next step ID:', nextStepId, 'from step:', chatState.currentStep);

      if (nextStepId === 'complete' || chatState.currentStep === 'complete') {
        setChatState(prev => ({
          ...prev,
          isCompleted: true,
          leadData: updatedLeadData
        }));
      } else if (nextStepId && flow[nextStepId]) {
        const nextStep = flow[nextStepId];
        const botMessage: Message = {
          id: uuidv4(),
          type: 'bot',
          content: nextStep.question,
          timestamp: new Date()
        };

        setChatState(prev => ({
          ...prev,
          currentStep: nextStepId,
          messages: [...prev.messages, botMessage],
          leadData: updatedLeadData
        }));
      } else {
        logger.error('‚ùå Next step not found or invalid:', nextStepId, 'Available steps:', Object.keys(flow));

        const fallbackFlow = staticFlow.welcome;
        const fallbackMessage: Message = {
          id: uuidv4(),
          type: 'bot',
          content: 'Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÏûëÌï©ÎãàÎã§.\n\n' + fallbackFlow.question,
          timestamp: new Date()
        };

        setChatState(prev => ({
          ...prev,
          currentStep: 'welcome',
          messages: [...prev.messages, fallbackMessage],
          leadData: updatedLeadData
        }));
      }
    }, 1000);
  };

  const handleVerificationComplete = async (code: string) => {
    const updatedLeadData: LeadData = {
      ...chatState.leadData,
      phone: phoneNumber,
      verified: true
    };

    try {
      const leadId = phoneNumber.replace(/[^0-9]/g, '');

      const response = await fetch('/api/leads', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...updatedLeadData,
          id: leadId,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to save lead');
      }

      const flow = getCurrentFlow();
      const completeStep = flow['complete'] || {
        question: 'üéâ Îì±Î°ùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!\n\nÎπ†Î•∏ ÏãúÏùº ÎÇ¥Ïóê Ïó∞ÎùΩÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.\n88 CompanyÏôÄ Ìï®Íªò ÏÑ±Í≥µÏ†ÅÏù∏ Ï∞ΩÏóÖÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî!'
      };

      const thankYouMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: completeStep.question,
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, thankYouMessage],
        leadData: updatedLeadData,
        isCompleted: true
      }));
    } catch (error) {
      console.error('Error saving lead:', error);

      const errorMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: 'Ï£ÑÏÜ°Ìï©ÎãàÎã§. Îì±Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, errorMessage]
      }));
    }
  };

  const getProgressSteps = () => {
    // ÏôÑÎ£å ÏÉÅÌÉúÎ©¥ Ï†ÑÏ≤¥ Îã®Í≥Ñ
    if (chatState.isCompleted) {
      return totalSteps;
    }

    const flow = getCurrentFlow();
    if (!flow) return 0;

    // Î™®Îì† ÏßàÎ¨∏ Îã®Í≥ÑÎ•º order_index ÏàúÏúºÎ°ú Ï†ïÎ†¨
    const allSteps = Object.keys(flow)
      .filter(key => key !== 'complete' && key !== 'phoneVerification')
      .sort((a, b) => {
        const aStep = flow[a];
        const bStep = flow[b];
        // order_indexÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ ÏàúÏÑú
        const aOrder = (aStep as any)?.order_index ?? 999;
        const bOrder = (bStep as any)?.order_index ?? 999;
        return aOrder - bOrder;
      });

    // ÌòÑÏû¨ Îã®Í≥ÑÏùò Ïù∏Îç±Ïä§ Ï∞æÍ∏∞
    let currentStepIndex = allSteps.indexOf(chatState.currentStep);

    // phoneVerification ÏÉÅÌÉúÏùº ÎïåÎäî phone Îã®Í≥Ñ + 0.5Î°ú Í≥ÑÏÇ∞
    if (chatState.currentStep === 'phoneVerification') {
      const phoneIndex = allSteps.indexOf('phone');
      currentStepIndex = phoneIndex >= 0 ? phoneIndex : allSteps.length - 1;
      // Í≤ÄÏ¶ù Ï§ëÏùº ÎïåÎäî +0.5 ÏßÑÌñâÎ•†
      return Math.min(currentStepIndex + 1.5, totalSteps);
    }

    // welcome ÏÉÅÌÉúÏóêÏÑú ÏïÑÏßÅ ÎãµÎ≥ÄÏù¥ ÏóÜÏúºÎ©¥ 0
    if (chatState.currentStep === 'welcome' &&
        chatState.messages.filter(msg => msg.type === 'user').length === 0) {
      return 0;
    }

    // ÌòÑÏû¨ Îã®Í≥ÑÍπåÏßÄ ÏôÑÎ£åÌïú Îã®Í≥Ñ Ïàò (1-based indexing)
    return Math.min(currentStepIndex + 1, totalSteps);
  };

  if (isLoadingFlow) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50 dark:bg-gray-900">
        <div className="text-center">
          <Sparkles className="w-12 h-12 mx-auto mb-4 text-purple-600 animate-pulse" />
          <p className="text-gray-600 dark:text-gray-400">Î°úÎî© Ï§ë...</p>
        </div>
      </div>
    );
  }

  const flow = getCurrentFlow();
  const currentStep = flow[chatState.currentStep];

  if (!currentStep) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50 dark:bg-gray-900">
        <div className="text-center">
          <p className="text-red-600">Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-gray-50 dark:bg-gray-900">
      {!chatState.isCompleted && (
        <div className="bg-white dark:bg-gray-800 border-b dark:border-gray-700 px-4 py-2">
          <div className="max-w-4xl mx-auto">
            <ProgressBar currentStep={getProgressSteps()} totalSteps={totalSteps} />
          </div>
        </div>
      )}

      <div className="flex-1 overflow-y-auto px-4 py-6">
        <div className="max-w-4xl mx-auto space-y-4">
          {chatState.messages.map((message) => (
            <ChatMessage key={message.id} message={message} />
          ))}
          {isTyping && (
            <div className="flex items-center space-x-2 text-gray-500 dark:text-gray-400">
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
              </div>
              <span className="text-sm">ÏûÖÎ†• Ï§ë...</span>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
      </div>

      {!chatState.isCompleted && !isTyping && (
        <div className="bg-white dark:bg-gray-800 border-t dark:border-gray-700 px-4 py-4">
          <div className="max-w-4xl mx-auto">
            {currentStep.inputType === 'select' && currentStep.options && (
              <QuickReplyOptions
                options={currentStep.options}
                onSelect={handleUserInput}
              />
            )}
            {currentStep.inputType !== 'select' && chatState.currentStep !== 'phone' && (
              <ChatInput
                currentStep={currentStep}
                onSubmit={handleUserInput}
              />
            )}
            {chatState.currentStep === 'phone' && (
              <VerificationInput
                phoneNumber={phoneNumber}
                onVerify={handleVerificationComplete}
              />
            )}
          </div>
        </div>
      )}

      {chatState.isCompleted && (
        <div className="bg-white dark:bg-gray-800 border-t dark:border-gray-700 px-4 py-4">
          <div className="max-w-4xl mx-auto">
            <div className="text-center">
              <Sparkles className="w-12 h-12 mx-auto mb-3 text-purple-600" />
              <p className="text-gray-600 dark:text-gray-400">ÏÉÅÎã¥Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§</p>
              <button
                onClick={() => window.location.reload()}
                className="mt-4 px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
              >
                ÏÉàÎ°úÏö¥ ÏÉÅÎã¥ ÏãúÏûëÌïòÍ∏∞
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}