'use client';

import { useState, useEffect, useRef } from 'react';
import { ChatMessage } from './ChatMessage';
import { ChatInput } from './ChatInput';
import { ProgressBar } from './ProgressBar';
import { QuickReplyOptions } from './QuickReplyOptions';
import { VerificationInput } from './VerificationInput';
import { Message, ChatState, LeadData } from '@/lib/types';
import { questionManager } from '@/lib/chat/question-manager';
import { v4 as uuidv4 } from 'uuid';
import { Sparkles } from 'lucide-react';

export function SimpleChatInterface() {
  const [chatState, setChatState] = useState<ChatState>({
    currentStep: 'welcome',
    messages: [],
    leadData: {},
    isCompleted: false
  });

  const [isTyping, setIsTyping] = useState(false);
  const [phoneNumber, setPhoneNumber] = useState<string>('');
  const [flow, setFlow] = useState<Record<string, any>>({});
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [chatState.messages]);

  // Ï¥àÍ∏∞ Î°úÎìú Î∞è ÏóÖÎç∞Ïù¥Ìä∏ Í∞êÏßÄ
  useEffect(() => {
    const loadFlow = () => {
      const newFlow = questionManager.getFlow();
      setFlow(newFlow);

      // Ï≤´ Î≤àÏß∏ ÏßàÎ¨∏ ÌëúÏãú
      if (chatState.messages.length === 0 && newFlow['welcome']) {
        const welcomeMessage: Message = {
          id: uuidv4(),
          type: 'bot',
          content: newFlow['welcome'].question,
          timestamp: new Date()
        };

        setChatState(prev => ({
          ...prev,
          messages: [welcomeMessage]
        }));
      }
    };

    loadFlow();

    // ÏßàÎ¨∏ ÏóÖÎç∞Ïù¥Ìä∏ Í∞êÏßÄ
    const handleQuestionsUpdate = () => {
      const newFlow = questionManager.getFlow();
      setFlow(newFlow);
    };

    window.addEventListener('questionsUpdated', handleQuestionsUpdate);
    window.addEventListener('storage', (e) => {
      if (e.key === 'questions_updated' || e.key === 'chat_questions') {
        handleQuestionsUpdate();
      }
    });

    return () => {
      window.removeEventListener('questionsUpdated', handleQuestionsUpdate);
    };
  }, []);

  const handleUserInput = async (value: string) => {
    const currentStep = flow[chatState.currentStep];
    if (!currentStep) return;

    // Í≤ÄÏ¶ù
    if (currentStep.validation && !currentStep.validation(value)) {
      const errorMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: 'ÏûÖÎ†•ÌïòÏã† Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
        timestamp: new Date()
      };
      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, errorMessage]
      }));
      return;
    }

    // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    const userMessage: Message = {
      id: uuidv4(),
      type: 'user',
      content: value,
      timestamp: new Date()
    };

    setChatState(prev => ({
      ...prev,
      messages: [...prev.messages, userMessage]
    }));

    // Î¶¨Îìú Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    const updatedLeadData: LeadData = { ...chatState.leadData };
    const stepMapping: Record<string, keyof LeadData> = {
      'welcome': 'service',
      'customService': 'service',
      'budget': 'budget',
      'timeline': 'timeline',
      'details': 'message',
      'name': 'name',
      'phone': 'phone'
    };

    const dataKey = stepMapping[chatState.currentStep];
    if (dataKey) {
      (updatedLeadData as any)[dataKey] = value;
    }

    if (chatState.currentStep === 'phone') {
      setPhoneNumber(value);
    }

    // ÌÉÄÏù¥Ìïë Ìö®Í≥º
    setIsTyping(true);
    setTimeout(async () => {
      setIsTyping(false);

      const nextStepId = currentStep.nextStep ? currentStep.nextStep(value) : 'complete';

      if (nextStepId === 'complete' || chatState.currentStep === 'complete') {
        setChatState(prev => ({
          ...prev,
          isCompleted: true,
          leadData: updatedLeadData
        }));
      } else if (nextStepId && flow[nextStepId]) {
        const nextStep = flow[nextStepId];
        const botMessage: Message = {
          id: uuidv4(),
          type: 'bot',
          content: nextStep.question,
          timestamp: new Date()
        };

        setChatState(prev => ({
          ...prev,
          currentStep: nextStepId,
          messages: [...prev.messages, botMessage],
          leadData: updatedLeadData
        }));
      }
    }, 1000);
  };

  const handleVerificationComplete = async (code: string) => {
    const updatedLeadData: LeadData = {
      ...chatState.leadData,
      phone: phoneNumber,
      verified: true
    };

    try {
      const leadId = phoneNumber.replace(/[^0-9]/g, '');

      const response = await fetch('/api/leads', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...updatedLeadData,
          id: leadId,
          timestamp: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to save lead');
      }

      const completeMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: flow['complete']?.question || 'üéâ Îì±Î°ùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§! Îπ†Î•∏ ÏãúÏùº ÎÇ¥Ïóê Ïó∞ÎùΩÎìúÎ¶¨Í≤†ÏäµÎãàÎã§.',
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, completeMessage],
        leadData: updatedLeadData,
        isCompleted: true
      }));
    } catch (error) {
      console.error('Error saving lead:', error);

      const errorMessage: Message = {
        id: uuidv4(),
        type: 'bot',
        content: 'Ï£ÑÏÜ°Ìï©ÎãàÎã§. Îì±Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
        timestamp: new Date()
      };

      setChatState(prev => ({
        ...prev,
        messages: [...prev.messages, errorMessage]
      }));
    }
  };

  const getProgressSteps = () => {
    // ÎèôÏ†ÅÏúºÎ°ú Ï¥ù Îã®Í≥Ñ Ïàò Í≥ÑÏÇ∞
    const questions = questionManager.getQuestions();
    const activeQuestions = questions.filter(q => q.is_active !== false);

    // customServiceÎäî Ï°∞Í±¥Î∂ÄÏù¥ÎØÄÎ°ú Ï†úÏô∏
    const mainQuestions = activeQuestions.filter(q => q.step !== 'customService');

    // phoneVerificationÏùÄ ÏûêÎèôÏúºÎ°ú Ï∂îÍ∞ÄÎêòÎØÄÎ°ú +1
    const hasPhoneStep = mainQuestions.some(q => q.step === 'phone');
    const totalSteps = mainQuestions.length + (hasPhoneStep ? 1 : 0);

    // ÌòÑÏû¨ Îã®Í≥ÑÏùò Ïù∏Îç±Ïä§ Ï∞æÍ∏∞ (customService Ï†úÏô∏Îêú Î™©Î°ùÏóêÏÑú)
    const currentQuestionIndex = mainQuestions.findIndex(q => q.step === chatState.currentStep);

    // ÌäπÏàò Îã®Í≥Ñ Ï≤òÎ¶¨
    if (chatState.currentStep === 'phoneVerification') {
      return totalSteps - 1; // ÎßàÏßÄÎßâÏóêÏÑú Îëê Î≤àÏß∏
    }

    if (chatState.currentStep === 'complete') {
      return totalSteps; // ÎßàÏßÄÎßâ
    }

    // customServiceÎäî ÏßÑÌñâÎèÑÏóê Ìè¨Ìï®ÌïòÏßÄ ÏïäÏßÄÎßå ÌòÑÏû¨ Îã®Í≥ÑÏùº ÎïåÎäî Ïù¥Ï†Ñ Îã®Í≥Ñ Ïú†ÏßÄ
    if (chatState.currentStep === 'customService') {
      // welcomeÍ≥º Í∞ôÏùÄ ÏßÑÌñâÎèÑÎ°ú Ï≤òÎ¶¨ (ÏòµÏÖò ÏÑ†ÌÉù Ï§ë)
      return 1;
    }

    // ÏùºÎ∞ò ÏßàÎ¨∏Ïùò Í≤ΩÏö∞
    if (currentQuestionIndex !== -1) {
      return currentQuestionIndex + 1;
    }

    // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ ÏàòÎ°ú Ìè¥Î∞±
    const userMessageCount = chatState.messages.filter(msg => msg.type === 'user').length;
    return Math.min(userMessageCount, totalSteps);
  };

  const getTotalSteps = () => {
    const questions = questionManager.getQuestions();
    const activeQuestions = questions.filter(q => q.is_active !== false);

    // customServiceÎäî Ï°∞Í±¥Î∂ÄÏù¥ÎØÄÎ°ú Ï†úÏô∏ (ÏÑ†ÌÉùÏ†Å)
    const mainQuestions = activeQuestions.filter(q => q.step !== 'customService');

    // phoneVerificationÏùÄ ÏûêÎèôÏúºÎ°ú Ï∂îÍ∞ÄÎêòÎØÄÎ°ú +1
    const hasPhoneStep = mainQuestions.some(q => q.step === 'phone');
    return mainQuestions.length + (hasPhoneStep ? 1 : 0);
  };

  const currentStep = flow[chatState.currentStep];

  if (!currentStep && !chatState.isCompleted) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-50 dark:bg-gray-900">
        <div className="text-center">
          <Sparkles className="w-12 h-12 mx-auto mb-4 text-purple-600 animate-pulse" />
          <p className="text-gray-600 dark:text-gray-400">Î°úÎî© Ï§ë...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-gray-50 dark:bg-gray-900">
      {!chatState.isCompleted && (
        <div className="bg-white dark:bg-gray-800 border-b dark:border-gray-700 px-4 py-2">
          <div className="max-w-4xl mx-auto">
            <ProgressBar currentStep={getProgressSteps()} totalSteps={getTotalSteps()} />
          </div>
        </div>
      )}

      <div className="flex-1 overflow-y-auto px-4 py-6">
        <div className="max-w-4xl mx-auto space-y-4">
          {chatState.messages.map((message) => (
            <ChatMessage key={message.id} message={message} />
          ))}
          {isTyping && (
            <div className="flex items-center space-x-2 text-gray-500 dark:text-gray-400">
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                <div className="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
              </div>
              <span className="text-sm">ÏûÖÎ†• Ï§ë...</span>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>
      </div>

      {!chatState.isCompleted && !isTyping && currentStep && (
        <div className="bg-white dark:bg-gray-800 border-t dark:border-gray-700 px-4 py-4">
          <div className="max-w-4xl mx-auto">
            {currentStep.inputType === 'select' && currentStep.options && (
              <QuickReplyOptions
                options={currentStep.options}
                onSelect={handleUserInput}
              />
            )}
            {currentStep.inputType !== 'select' && chatState.currentStep !== 'phone' && (
              <ChatInput
                currentStep={currentStep}
                onSubmit={handleUserInput}
              />
            )}
            {chatState.currentStep === 'phone' && (
              <VerificationInput
                phoneNumber={phoneNumber}
                onVerify={handleVerificationComplete}
              />
            )}
          </div>
        </div>
      )}

      {chatState.isCompleted && (
        <div className="bg-white dark:bg-gray-800 border-t dark:border-gray-700 px-4 py-4">
          <div className="max-w-4xl mx-auto">
            <div className="text-center">
              <Sparkles className="w-12 h-12 mx-auto mb-3 text-purple-600" />
              <p className="text-gray-600 dark:text-gray-400">ÏÉÅÎã¥Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§</p>
              <button
                onClick={() => window.location.reload()}
                className="mt-4 px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
              >
                ÏÉàÎ°úÏö¥ ÏÉÅÎã¥ ÏãúÏûëÌïòÍ∏∞
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}